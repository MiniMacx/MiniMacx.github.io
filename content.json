{"pages":[{"title":"404","text":".article-header { padding: 0; padding-top: 26px; border-left: none; text-align: center; } .article-header:hover { border-left: none; } .article-title { font-size: 2.1em; } strong a { color: #747474; } .article-meta { display: none; } .share { display: none; } .ds-meta { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } #container .article-info-post.article-info { display: none; } #container .article .article-title { padding: 0; }","link":"/404.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"微信礼品卡踩坑之旅","text":"文中所描述的项目截止于2018-10，因此文章内容具有一定时效性，请大家注意。本文为博主第一篇博客，不足之处还请各位巨佬们指出:D撰写这篇博客初衷有二：记录自己第一个正式项目的开发历程、为需要开通微信礼品卡/实现自定义礼品卡小程序的各位分享一些流程与思路，因此本文总体划为以下部分： 官方礼品卡部署 自定义小程序实现 项目来自于某公司甲方爸爸的两版需求：第一版为开通官方礼品卡小程序，旗下会员可在其他小程序中利用礼品卡为账户充值，第二版模仿星巴克用星说，开发新的礼品卡小程序。本文面向具有一定经验的微信开发者，微信相关的其他功能（开发者配置、登录、支付等）不再一一赘述。SDK用的是班纳睿大大的WxJava，在此安利一波～ 官方礼品卡部署先附上官方槽点满满充满诚意的礼品卡文档。这是目前我见过最长（所有内容挤进一篇）、最乱（没有目录，排版不统一，甚至有错别字）的微信文档了。大致讲了以下几点： 小程序演示 开通条件 礼品卡CRUD 货架CRUD 绑定支付商户 代码上传 订单查询 事件推送 使用方式 退款 发票 外链跳转 压根不会鸟你的联系我们 WOWEE～看起来啥都给我们api caller准备好了，接下来调就完事了咩～LET’s GO DUDE! 首先注意1、礼品卡亦属于卡券的一个分类，建议先查阅微信卡券文档以便了解相关字段与词汇的含义。2、开通礼品卡的公众号门槛较高，若需开通带储值功能的礼品卡，更是要若干认证与手续，记得提前准备，个人认证的公众号无法申请礼品卡功能。3、创建小程序不需要写代码，完全靠接口调用生成。 接入准备 公众号-&gt;已认证 公众号开通-&gt;卡券功能 公众号开通-&gt;支付功能(微信认证) 微信公众号-&gt;快速关联小程序(创建小程序账号) 小程序账号-&gt;绑定 商户号(微信支付) 礼品卡创建json数据，分礼品卡与兑换卡两种，在购买页会有区别。看过卡券文档的朋友们可能会发现，微信没有为卡券做一个完整的分类统计。在这里我可以说，会员卡和礼品卡是目前唯二可以放入“卡”中的，其余皆为票券，这也为后续的自定义礼品卡实现提供了思路。 礼品卡的文档中没有对每个字段做详细图解，不过我们可以参照会员卡逐一对照： 货架创建json数据，货架作为礼品卡的载体，可生成多个，但只能上线其中一个，每行标题对应category_list中的元素，每一小块代表theme_list中的一个元素，将创建完成的礼品卡放入theme_list的item_list字段中，其余字段可自调，创建成功后返回的page_id需要保存，后续会用到。货架包含的字段较多，文档中有详细的解释，这里就不展开了。特别注意：创建货架的接口每天有调用次数限制，约为10次/天，调用前建议校验json格式，检查一遍字段的长度限制。 开通支付 调文档8.1中的接口，带上你公众号的商户号即可，调用成功后访问返回结果中的Url，登录商户平台，产品中心-&gt;微信礼品卡，点击开通。 8.2接口，带上小程序appid与商户号，成功即开通完成。 上传生成代码调用8.3接口，带上对应的appid+page_id，等待片刻后即可在小程序后台看到体验版，扫码进去后看到的约莫是这样子： emmm…..基本功能算是都有了，只是这样式…啧啧 退款问题 首先国家法律规定，必须有退款功能。所以要做，要是礼品卡过期了、失效了，这也是能退款的，除非你设置了长期有效(不要小看，要相信你的用户是个大牛叉) 优缺点小结 官方支持，从创建到部署轻松+愉快。可选字段多，扩展业务很方便。有独特的送卡消息，支持扫码消费或者线下核销。 样式普通，布局简陋，颜值全靠图片衬托。 自定义小程序实现 尽管官方的礼品卡小程序不是很美观，但其他方面还是可以接受的。若要是需求方提到了星巴克用星说这玩意并且要给他个差不多样子的，那你就麻烦了。接下来你可能会一阵懵逼，陷入江局——它啥都跟官方的礼品卡小程序一样，但他娘的界面还比你好看，甚至还会有”之前太丑肯定是字段调得不对”的错觉，咱们先看看啥叫别人家的小程序： 星巴克用星说是微信团队特别定制的礼品卡小程序，也是自它出现以后，官方才开放了礼品卡的相关文档，可以说是其他礼品卡小程序的始祖。 概括了一下用星说之于其他礼品卡小程序所没有的features： 带阴影的块状元素，看起来更加优雅 支持gif的轮播图广告 星巴克风格的icon 全新的购买界面 节日期间首页会有活动弹窗 开始之前先放下发麻的头皮，掏出度娘和谷哥捣腾一番后，发觉论坛上也是各种求方案求思路，最有趣的是，还有专门接这类订制礼品卡小程序的公司。其实看到这里我就放心了，既然有人实现了，那它就是可行的，之后我提供的实现方案，不是很优雅，也不够完美，欢迎有做过这类的同好在评论区中分享自己的思路。本节自定义小程序，我们的目标是模仿星巴克用星说，有2套思路： 反编译官方小程序获得源码，在其基础上扩展（TODO） 完全自定义，官方未提供的功能寻求替代方案 反编译实现由于工期原因，也考虑到小程序没法过审的风险，没有尝试这一套方案。最近会尝试反编译，看看能否拿到原生礼品卡小程序的源码。（TODO） 完全自定义实现咨询了相关公司（然鹅不肯说=。=），review原生小程序，以及后期的实操经历，我先把这几个无法按原礼品卡小程序实现的点放在这里： 官方礼品卡不能复用(会显示为’已领取’状态但无法领卡) 不能发礼品卡类型的消息给用户 无法选择好友或群并返回其信息 特别是接口开放部分，只要是好友链相关，微信都不会给你开放，更不用说选择好友后返回其昵称与头像了，领卡这部分也是一大问题，查阅了JS-SDK和小程序文档，并没有发现可以向用户发送礼品卡信息的方法。所以说，要百分百模仿用星说是不可能的。 Key Points总的来说，要完成一个像样的实现，以下是关键： 找到一种合适的卡券替代礼品卡 选择好友的替代方案 领卡的替代方案 解决方案会员卡代替礼品卡在上文中有提到过，礼品卡和会员卡是唯二可以放入”卡”中的卡券。会员卡拥有的字段比礼品卡丰富很多，完全可以替换。在事件推送上，会员卡遵循微信卡券的推送格式，而礼品卡有其独特类型的推送事件，比如超过24小时后未领取退回的事件，这可以做成定时任务代替，问题不大。接口方面，虽然会员卡没有核销接口，但也能用失效接口代替，其余也是应有尽有。特别注意：用户每次购买应新建一张会员卡，即新的card_id，若发放给用户的卡id相同，当用户选择不同卡面时必会用到更新接口，而更新卡面会影响该id下的所有卡，包括其他用户已领取的会员卡，从而导致所有会员卡卡面都会变化。 使用分享功能指定发送对象分享功能是为数不多用户间发送消息的途径，既然小程序内没法指定发送对象，那我们就直接发送分享消息，虽然不够美观，但也能引导用户点开小程序，这也意味着后续的领卡环节将在小程序里完成。 小程序内调起领卡在小程序内做一个领取页，后台先准备好待领取卡的JsApiTicket，前段调用小程序的发卡接口调起官方领卡页面，放入卡包后跳转至领取成功的页面。整个环节最突兀的是官方领卡显示为会员卡且无法更改，这是做的不好的地方。 成品展示 按需求做了单品购买 增加抢红包模式 关于样式方面，可以参考liaoruochen的Starbucks，做的很全面，很漂亮。 结束语感谢和我共事的小老弟们，在样式上花了很多功夫，也在这个项目上付出了很多时间，感谢你们。 参考文章 [简书] 微信礼品卡","link":"/2019/01/28/微信礼品卡踩坑之旅/"},{"title":"Netty 入门笔记","text":"一、 简介1. 是什么？官方对于Netty的介绍： Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。 本质来说，它是一个把java nio包封装得很好的网络应用框架，具有以下特点： 高并发，低延迟 高扩展，API使用简单，开发门槛低 非阻塞 基于事件驱动的编程，我们只需专注于业务本身，实现每一个必要的handler，省去了许多繁杂的底层操作，Netty就是这样，它的存在大大降低了NIO程序的编程复杂度。 Netty的优点归功于其封装性好之外，还跟NIO（Nonblocking I/O，非阻塞IO）有很大的关系。 2. BIO与NIONetty是一款基于NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架，对比于BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。 那么BIO与NIO的差距在哪里呢？ 客户端监听（Listen）时，Accept是阻塞的，只有新连接来了，Accept才会返回，主线程才能继续。 读写socket时，Read是阻塞的，只有请求消息来了，Read才能返回，子线程才能继续处理。 读写socket时，Write是阻塞的，只有客户端把消息收了，Write才能返回，子线程才能继续读取下一个请求。 传统的BIO模式下，从头到尾的所有线程都是阻塞的，这些线程就干等着，占用系统的资源，什么事也不干。也就是说，一个线程只能处理一个连接。 非阻塞IO会进行持续的轮询（polling）,以查看某个操作是否就绪。 “非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。 Java NIO的非阻塞模式，是通过多路复用IO技术实现的，多路复用的核心就是通过Selector来轮询注册在其上的Channel，当发现某个或者多个Channel处于就绪状态后，从阻塞状态返回就绪的Channel的选择键集合，进行IO操作。如果什么事都没得做，它也不会死循环，它会将线程休眠起来，直到下一个事件来了再继续干活。也就是说，一个线程就能处理多个连接。 这个优点在连接增多时尤其明显，在高并发场景中，动辄数万级到百万级的连接，使用传统的BIO模型，即使有线程池的加持，消耗的资源还是太多，服务器承受不了压力很容易gg。 NIO让我们使用较少的线程处理多个连接的同时，也大大减少了上下文切换的开销，当某个线程处于空闲状态时，还能安排它做其他任务。 3. Why Netty？NIO的不足Java 1.4版本推出的nio包提供了NIO的模型，然而现在我们很少能看到使用原生nio类库开发出的应用，主要有以下几个问题： 1) 类库和API繁杂，使用麻烦。 2) NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序。 3) 需要花大量的时间健壮自己的程序。例如处理断线重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流等等。 4) NIO的epoll bug，它会导致Selector空轮询，最终导致CPU 100%。直到JDK1.7版本该问题仍旧存在，只不过该bug发生概率降低了一些而已，并没有被解决，1.8才修复。 Netty的强势1) API使用简单，开发门槛低； 2) 功能强大，预置了多种编解码功能，支持多种主流协议； 3) 定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展； 4) 性能高，通过与其它业界主流的NIO框架对比，Netty的综合性能最优； 5) 成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼； 6) 社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入； 7) 经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用。 正是因为这些优点，Netty成为了Java NIO编程的首选框架。 二、 Netty的应用1. Netty能做什么？Netty本身是一个网络通讯框架，很多网络应用，RPC，分布式框架都有使用Netty进行网络通讯。通俗的说，Netty就是一个好使的处理Socket的框架。 有了Netty，你可以实现自己的HTTP服务器，FTP服务器，UDP服务器，RPC服务器，WebSocket服务器，Redis的Proxy服务器，MySQL的Proxy服务器等等。 2. 使用Netty的产品Dubbo阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信。 RocketMQ淘宝的消息中间件, 在消息生产者和消息消费者之间，也采用 Netty 进行高性能、异步通信。 Hadoop经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨节点通信，它的 Netty Service 基于 Netty 框架二次封装实现。 各种游戏服务器使用Java语言的手游服务端和大型网游，大多使用Netty 作为通信组件，它本身提供了 TCP/UDP 和 HTTP 协议栈，非常方便定制和开发私有协议栈。账号登陆服务器、地图服务器之间可以方便的通过 Netty 进行高性能的通信。 三、Netty demo一次普通的Socket连接建立一个正常的serverSocket： 阻塞I/O 123456789101112131415161718192021222324252627282930313233public class PlainOioServer { public void serve(int port) throws IOException { final ServerSocket socket = new ServerSocket(port); try { for (;;) { final Socket clientSocket = socket.accept(); System.out.println(\"Accepted connection from \" + clientSocket); new Thread(new Runnable() { @Override public void run() { OutputStream out; try { out = clientSocket.getOutputStream(); out.write(\"Hi!\\r\\n\".getBytes(Charset.forName(\"UTF-8\"))); out.flush(); clientSocket.close(); } catch (IOException e) { e.printStackTrace(); try { clientSocket.close(); } catch (IOException ex) { // ignore on close } } } }).start(); } } catch (IOException e) { e.printStackTrace(); } }} 非阻塞I/O 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class PlainNioServer { public void serve(int port) throws IOException { ServerSocketChannel serverChannel = ServerSocketChannel.open(); serverChannel.configureBlocking(false); ServerSocket ss = serverChannel.socket(); InetSocketAddress address = new InetSocketAddress(port); ss.bind(address); Selector selector = Selector.open(); serverChannel.register(selector, SelectionKey.OP_ACCEPT); final ByteBuffer msg = ByteBuffer.wrap(\"Hi!\\r\\n\".getBytes()); for (;;) { try { selector.select(); } catch (IOException ex) { ex.printStackTrace(); // handle exception break; } Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator(); while (iterator.hasNext()) { SelectionKey key = iterator.next(); iterator.remove(); try { if (key.isAcceptable()) { ServerSocketChannel server = (ServerSocketChannel)key.channel(); SocketChannel client = server.accept(); client.configureBlocking(false); client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, msg.duplicate()); System.out.println( \"Accepted connection from \" + client); } if (key.isWritable()) { SocketChannel client = (SocketChannel)key.channel(); ByteBuffer buffer = (ByteBuffer)key.attachment(); while (buffer.hasRemaining()) { if (client.write(buffer) == 0) { break; } } client.close(); } } catch (IOException ex) { key.cancel(); try { key.channel().close(); } catch (IOException cex) { // 在关闭时忽略 } } } } }} Netty 12345678910111213141516171819202122232425262728293031public class NettyOioServer { public void server(int port) throws Exception { final ByteBuf buf = Unpooled.unreleasableBuffer( Unpooled.copiedBuffer(\"Hi!\\r\\n\", Charset.forName(\"UTF-8\"))); EventLoopGroup group = new OioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap(); //1 b.group(group) //2 .channel(OioServerSocketChannel.class) .localAddress(new InetSocketAddress(port)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {//3 @Override public void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new ChannelInboundHandlerAdapter() { //4 @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);//5 } }); } }); ChannelFuture f = b.bind().sync(); //6 f.channel().closeFuture().sync(); } finally { group.shutdownGracefully().sync(); //7 } }} 相关概念 java nio的Channel、Buffer、Selector在Netty中做了更高层的抽象。 Channel 数据传输流，与channel相关的概念有以下四个： Channel一览 Channel，表示一个连接，可以理解为每一个请求，就是一个Channel。ChannelHandler，核心处理业务就在这里，用于处理业务请求。ChannelHandlerContext，用于传输业务数据。ChannelPipeline，用于保存处理过程需要用到的ChannelHandler和ChannelHandlerContext。 ByteBuf ByteBuf是一个存储字节的容器，最大特点就是使用方便，它既有自己的读索引和写索引，方便你对整段字节缓存进行读写，也支持get/set，方便你对其中每一个字节进行读写，他的数据结构如下图所示： ByteBuf数据结构 他有三种使用模式： Heap Buffer 堆缓冲区 堆缓冲区是ByteBuf最常用的模式，他将数据存储在堆空间。 Direct Buffer 直接缓冲区 直接缓冲区是ByteBuf的另外一种常用模式，他的内存分配都不发生在堆，jdk1.4引入的nio的ByteBuffer类允许jvm通过本地方法调用分配内存，这样做有两个好处 通过免去中间交换的内存拷贝, 提升IO处理速度; 直接缓冲区的内容可以驻留在垃圾回收扫描的堆区以外。 DirectBuffer 在 -XX:MaxDirectMemorySize=xxM大小限制下, 使用 Heap 之外的内存, GC对此”无能为力”,也就意味着规避了在高负载下频繁的GC过程对应用线程的中断影响. Composite Buffer 复合缓冲区 复合缓冲区相当于多个不同ByteBuf的视图，这是netty提供的，jdk不提供这样的功能。 Codec Netty中的编码/解码器，通过他你能完成字节与pojo、pojo与pojo的相互转换，从而达到自定义协议的目的。 发一个Http请求Netty对Http请求/相应做了封装，如下图： HTTP Request 第一部分是包含的头信息 HttpContent 里面包含的是数据，可以后续有多个 HttpContent 部分 LastHttpContent 标记是 HTTP request 的结束，同时可能包含头的尾部信息 完整的 HTTP request，由1，2，3组成 一次http请求并不是通过一次对话完成的，他中间可能有很多次的连接。每一次对话都会建立一个channel，并且一个ChannelInboundHandler一般是不会同时去处理多个Channel的。 如何在一个Channel里面处理一次完整的Http请求？这就要用到我们上图提到的FullHttpRequest，我们只需要在使用netty处理channel的时候，只处理消息是FullHttpRequest的Channel，这样我们就能在一个ChannelHandler中处理一个完整的Http请求了。 HTTP response 第一部分是包含的头信息 HttpContent 里面包含的是数据，可以后续有多个 HttpContent 部分 LastHttpContent 标记是 HTTP response 的结束，同时可能包含头的尾部信息 完整的 HTTP response，由1，2，3组成 四、Netty为何快？串行化 串行无锁化设计，在IO线程内部进行串行操作，避免多线程竞争导致的性能下降。 通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优 减少上下文切换，以及状态数据的同步 零拷贝NIO中的另一大特性——零拷贝，当他需要接收数据的时候，他会在堆内存之外开辟一块内存，数据就直接从IO读到了那块内存中去，在netty里面通过ByteBuf可以直接对这些数据进行直接操作，从而加快了传输速度。 五、Netty学习资料Netty官网 Netty权威指南 netty-example 并发编程网","link":"/2019/04/12/Netty/"}],"tags":[{"name":"微信","slug":"微信","link":"/tags/微信/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Netty","slug":"Netty","link":"/tags/Netty/"}],"categories":[]}