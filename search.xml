<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Netty 入门笔记</title>
      <link href="/2019/04/12/Netty/"/>
      <url>/2019/04/12/Netty/</url>
      
        <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1089449-7079e3b4d875b53c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/313/format/webp" alt></p><h2 id="一、-简介"><a href="#一、-简介" class="headerlink" title="一、 简介"></a>一、 简介</h2><h3 id="1-是什么？"><a href="#1-是什么？" class="headerlink" title="1. 是什么？"></a>1. 是什么？</h3><p>官方对于Netty的介绍：</p><blockquote><p>Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。</p></blockquote><p>本质来说，它是一个把java nio包封装得很好的网络应用框架，具有以下特点：</p><blockquote><ul><li>高并发，低延迟</li><li>高扩展，API使用简单，开发门槛低</li><li>非阻塞</li></ul></blockquote><p>基于事件驱动的编程，我们只需专注于业务本身，实现每一个必要的handler，省去了许多繁杂的底层操作，Netty就是这样，它的存在大大降低了NIO程序的编程复杂度。</p><p>Netty的优点归功于其封装性好之外，还跟NIO（Nonblocking I/O，非阻塞IO）有很大的关系。</p><a id="more"></a><h3 id="2-BIO与NIO"><a href="#2-BIO与NIO" class="headerlink" title="2. BIO与NIO"></a>2. BIO与NIO</h3><p>Netty是一款基于NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架，对比于BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。</p><p>那么BIO与NIO的差距在哪里呢？</p><p> <img src="https://upload-images.jianshu.io/upload_images/1089449-546a563c9822ce16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/548/format/webp" alt="阻塞IO的通信方式"></p><ol><li>客户端监听（Listen）时，Accept是阻塞的，只有新连接来了，Accept才会返回，主线程才能继续。</li><li>读写socket时，Read是阻塞的，只有请求消息来了，Read才能返回，子线程才能继续处理。</li><li>读写socket时，Write是阻塞的，只有客户端把消息收了，Write才能返回，子线程才能继续读取下一个请求。</li></ol><p>传统的BIO模式下，从头到尾的所有线程都是阻塞的，这些线程就干等着，占用系统的资源，什么事也不干。也就是说，<strong>一个线程只能处理一个连接</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/1089449-9eebe781fba495fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/572/format/webp" alt="非阻塞IO的通信方式"></p><p>非阻塞IO会进行持续的轮询（polling）,以查看某个操作是否就绪。</p><p>“非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 ‘被’ CPU光顾”。</p><p>Java NIO的非阻塞模式，是通过多路复用IO技术实现的，多路复用的核心就是通过Selector来轮询注册在其上的Channel，当发现某个或者多个Channel处于就绪状态后，从阻塞状态返回就绪的Channel的选择键集合，进行IO操作。如果什么事都没得做，它也不会死循环，它会将线程休眠起来，直到下一个事件来了再继续干活。也就是说，<strong>一个线程就能处理多个连接</strong>。</p><p>这个优点在连接增多时尤其明显，在高并发场景中，动辄数万级到百万级的连接，使用传统的BIO模型，即使有线程池的加持，消耗的资源还是太多，服务器承受不了压力很容易gg。</p><p>NIO让我们使用较少的线程处理多个连接的同时，也大大减少了上下文切换的开销，当某个线程处于空闲状态时，还能安排它做其他任务。</p><h3 id="3-Why-Netty？"><a href="#3-Why-Netty？" class="headerlink" title="3. Why Netty？"></a>3. Why Netty？</h3><h4 id="NIO的不足"><a href="#NIO的不足" class="headerlink" title="NIO的不足"></a>NIO的不足</h4><p>Java 1.4版本推出的nio包提供了NIO的模型，然而现在我们很少能看到使用原生nio类库开发出的应用，主要有以下几个问题：</p><p>1)      类库和API繁杂，使用麻烦。</p><p>2)      NIO编程涉及到Reactor模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的NIO程序。</p><p>3)      需要花大量的时间健壮自己的程序。例如处理断线重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流等等。</p><p> 4)      NIO的epoll bug，它会导致Selector空轮询，最终导致CPU 100%。直到JDK1.7版本该问题仍旧存在，只不过该bug发生概率降低了一些而已，并没有被解决，1.8才修复。</p><h4 id="Netty的强势"><a href="#Netty的强势" class="headerlink" title="Netty的强势"></a>Netty的强势</h4><p>1)      API使用简单，开发门槛低；</p><p>2)      功能强大，预置了多种编解码功能，支持多种主流协议；</p><p>3)      定制能力强，可以通过ChannelHandler对通信框架进行灵活的扩展；</p><p>4)      性能高，通过与其它业界主流的NIO框架对比，Netty的综合性能最优；</p><p>5)      成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；</p><p>6)      社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会被加入；</p><p>7)      经历了大规模的商业应用考验，质量已经得到验证。在互联网、大数据、网络游戏、企业应用、电信软件等众多行业得到成功商用，证明了它可以完全满足不同行业的商业应用。</p><p>正是因为这些优点，Netty成为了Java NIO编程的首选框架。</p><h2 id="二、-Netty的应用"><a href="#二、-Netty的应用" class="headerlink" title="二、 Netty的应用"></a>二、 Netty的应用</h2><h3 id="1-Netty能做什么？"><a href="#1-Netty能做什么？" class="headerlink" title="1. Netty能做什么？"></a>1. Netty能做什么？</h3><p>Netty本身是一个网络通讯框架，很多网络应用，RPC，分布式框架都有使用Netty进行网络通讯。通俗的说，<strong>Netty就是一个好使的处理Socket的框架</strong>。</p><p>有了Netty，你可以实现自己的HTTP服务器，FTP服务器，UDP服务器，RPC服务器，WebSocket服务器，Redis的Proxy服务器，MySQL的Proxy服务器等等。</p><h3 id="2-使用Netty的产品"><a href="#2-使用Netty的产品" class="headerlink" title="2. 使用Netty的产品"></a>2. 使用Netty的产品</h3><h4 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h4><p>阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信。</p><h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p>淘宝的消息中间件, 在消息生产者和消息消费者之间，也采用 Netty 进行高性能、异步通信。</p><h4 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h4><p>经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨节点通信，它的 Netty Service 基于 Netty 框架二次封装实现。</p><h4 id="各种游戏服务器"><a href="#各种游戏服务器" class="headerlink" title="各种游戏服务器"></a>各种游戏服务器</h4><p>使用Java语言的手游服务端和大型网游，大多使用Netty 作为通信组件，它本身提供了 TCP/UDP 和 HTTP 协议栈，非常方便定制和开发私有协议栈。账号登陆服务器、地图服务器之间可以方便的通过 Netty 进行高性能的通信。</p><h2 id="三、Netty-demo"><a href="#三、Netty-demo" class="headerlink" title="三、Netty demo"></a>三、Netty demo</h2><h4 id="一次普通的Socket连接"><a href="#一次普通的Socket连接" class="headerlink" title="一次普通的Socket连接"></a>一次普通的Socket连接</h4><p>建立一个正常的serverSocket：</p><ul><li>阻塞I/O</li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlainOioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> ServerSocket socket = <span class="hljs-keyword">new</span> ServerSocket(port); </span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="hljs-keyword">final</span> Socket clientSocket = socket.accept(); </span><br><span class="line">                System.out.println(<span class="hljs-string">"Accepted connection from "</span> + clientSocket);</span><br><span class="line">                <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;                 </span><br><span class="line">                    <span class="hljs-meta">@Override</span></span><br><span class="line">                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                        OutputStream out;</span><br><span class="line">                        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                            out = clientSocket.getOutputStream();</span><br><span class="line">                            out.write(<span class="hljs-string">"Hi!\r\n"</span>.getBytes(Charset.forName(<span class="hljs-string">"UTF-8"</span>)));   </span><br><span class="line">                            out.flush();</span><br><span class="line">                            clientSocket.close();           </span><br><span class="line">                        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                                clientSocket.close();</span><br><span class="line">                            &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                                <span class="hljs-comment">// ignore on close</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();                                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>非阻塞I/O</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlainNioServer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverChannel = ServerSocketChannel.open();</span><br><span class="line">        serverChannel.configureBlocking(<span class="hljs-keyword">false</span>);</span><br><span class="line">        ServerSocket ss = serverChannel.socket();</span><br><span class="line">        InetSocketAddress address = <span class="hljs-keyword">new</span> InetSocketAddress(port);</span><br><span class="line">        ss.bind(address);                             </span><br><span class="line">        Selector selector = Selector.open();         </span><br><span class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="hljs-keyword">final</span> ByteBuffer msg = ByteBuffer.wrap(<span class="hljs-string">"Hi!\r\n"</span>.getBytes());</span><br><span class="line">        <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                selector.select();                   </span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">                <span class="hljs-comment">// handle exception</span></span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys(); </span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator();</span><br><span class="line">            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;         </span><br><span class="line">                        ServerSocketChannel server =</span><br><span class="line">                                (ServerSocketChannel)key.channel();</span><br><span class="line">                        SocketChannel client = server.accept();</span><br><span class="line">                        client.configureBlocking(<span class="hljs-keyword">false</span>);</span><br><span class="line">                        client.register(selector, SelectionKey.OP_WRITE |</span><br><span class="line">                                SelectionKey.OP_READ, msg.duplicate()); </span><br><span class="line">                        System.out.println(</span><br><span class="line">                                <span class="hljs-string">"Accepted connection from "</span> + client);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (key.isWritable()) &#123;           </span><br><span class="line">                        SocketChannel client =</span><br><span class="line">                                (SocketChannel)key.channel();</span><br><span class="line">                        ByteBuffer buffer =</span><br><span class="line">                                (ByteBuffer)key.attachment();</span><br><span class="line">                        <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                            <span class="hljs-keyword">if</span> (client.write(buffer) == <span class="hljs-number">0</span>) &#123; </span><br><span class="line">                                <span class="hljs-keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        client.close();               </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    key.cancel();</span><br><span class="line">                    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                        key.channel().close();</span><br><span class="line">                    &#125; <span class="hljs-keyword">catch</span> (IOException cex) &#123;</span><br><span class="line">                        <span class="hljs-comment">// 在关闭时忽略</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Netty</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyOioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">server</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> ByteBuf buf = Unpooled.unreleasableBuffer(</span><br><span class="line">                Unpooled.copiedBuffer(<span class="hljs-string">"Hi!\r\n"</span>, Charset.forName(<span class="hljs-string">"UTF-8"</span>)));</span><br><span class="line">        EventLoopGroup group = <span class="hljs-keyword">new</span> OioEventLoopGroup();</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap();        <span class="hljs-comment">//1</span></span><br><span class="line"></span><br><span class="line">            b.group(group)                                    <span class="hljs-comment">//2</span></span><br><span class="line">             .channel(OioServerSocketChannel.class)</span><br><span class="line">             .localAddress(<span class="hljs-keyword">new</span> InetSocketAddress(port))</span><br><span class="line">             .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<span class="hljs-comment">//3</span></span><br><span class="line">                 <span class="hljs-meta">@Override</span></span><br><span class="line">                 <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span></span><br><span class="line"><span class="hljs-function">                     <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelInboundHandlerAdapter() &#123;            <span class="hljs-comment">//4</span></span><br><span class="line">                         <span class="hljs-meta">@Override</span></span><br><span class="line">                         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                             ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);<span class="hljs-comment">//5</span></span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">            ChannelFuture f = b.bind().sync();  <span class="hljs-comment">//6</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync();        <span class="hljs-comment">//7</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>  java nio的Channel、Buffer、Selector在Netty中做了更高层的抽象。</p><ul><li>Channel<br> 数据传输流，与channel相关的概念有以下四个：</li></ul><p><img src="https:////upload-images.jianshu.io/upload_images/1089449-afd9e14197e1ef11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/751/format/webp" alt></p><p>Channel一览</p><blockquote><p>Channel，表示一个连接，可以理解为每一个请求，就是一个Channel。<br><strong>ChannelHandler</strong>，核心处理业务就在这里，用于处理业务请求。<br>ChannelHandlerContext，用于传输业务数据。<br>ChannelPipeline，用于保存处理过程需要用到的ChannelHandler和ChannelHandlerContext。</p></blockquote><ul><li>ByteBuf<br> ByteBuf是一个存储字节的容器，最大特点就是<strong>使用方便</strong>，它既有自己的读索引和写索引，方便你对整段字节缓存进行读写，也支持get/set，方便你对其中每一个字节进行读写，他的数据结构如下图所示：</li></ul><p>  <img src="https:////upload-images.jianshu.io/upload_images/1089449-b1ec677f253b692a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/558/format/webp" alt></p><p>  ByteBuf数据结构</p><p>  他有三种使用模式：</p><ol><li><p>Heap Buffer 堆缓冲区<br>   堆缓冲区是ByteBuf最常用的模式，他将数据存储在堆空间。</p></li><li><p>Direct Buffer 直接缓冲区</p><p>   直接缓冲区是ByteBuf的另外一种常用模式，他的内存分配都不发生在堆，jdk1.4引入的nio的ByteBuffer类允许jvm通过本地方法调用分配内存，这样做有两个好处 </p><ul><li>通过免去中间交换的内存拷贝, 提升IO处理速度; 直接缓冲区的内容可以驻留在垃圾回收扫描的堆区以外。</li><li>DirectBuffer 在 -XX:MaxDirectMemorySize=xxM大小限制下, 使用 Heap 之外的内存, GC对此”无能为力”,也就意味着规避了在高负载下频繁的GC过程对应用线程的中断影响.</li></ul></li><li><p>Composite Buffer 复合缓冲区<br>   复合缓冲区相当于多个不同ByteBuf的视图，这是netty提供的，jdk不提供这样的功能。</p></li></ol><ul><li>Codec<br>  Netty中的编码/解码器，通过他你能完成字节与pojo、pojo与pojo的相互转换，从而达到自定义协议的目的。</li></ul><h4 id="发一个Http请求"><a href="#发一个Http请求" class="headerlink" title="发一个Http请求"></a>发一个Http请求</h4><p>Netty对Http请求/相应做了封装，如下图：</p><p><img src="https:////upload-images.jianshu.io/upload_images/1089449-5622baa38b81f5d0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/666/format/webp" alt="img"></p><ol><li><p>HTTP Request 第一部分是包含的头信息</p></li><li><p>HttpContent 里面包含的是数据，可以后续有多个 HttpContent 部分</p></li><li><p>LastHttpContent 标记是 HTTP request 的结束，同时可能包含头的尾部信息</p></li><li><p>完整的 HTTP request，由1，2，3组成</p></li></ol><p>一次http请求并不是通过一次对话完成的，他中间可能有很多次的连接。每一次对话都会建立一个channel，并且<strong>一个ChannelInboundHandler一般是不会同时去处理多个Channel的</strong>。</p><p>如何在一个Channel里面处理一次完整的Http请求？这就要用到我们上图提到的FullHttpRequest，我们只需要在使用netty处理channel的时候，只处理消息是FullHttpRequest的Channel，这样我们就能在一个ChannelHandler中处理一个完整的Http请求了。</p><p><img src="https:////upload-images.jianshu.io/upload_images/1089449-3dc45cd81e2e4423.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/664/format/webp" alt="img"></p><ol><li>HTTP response 第一部分是包含的头信息</li><li>HttpContent 里面包含的是数据，可以后续有多个 HttpContent 部分</li><li>LastHttpContent 标记是 HTTP response 的结束，同时可能包含头的尾部信息</li><li>完整的 HTTP response，由1，2，3组成</li></ol><h2 id="四、Netty为何快？"><a href="#四、Netty为何快？" class="headerlink" title="四、Netty为何快？"></a>四、Netty为何快？</h2><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p><img src="https://user-gold-cdn.xitu.io/2018/7/31/164edca358fcff46?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><blockquote><ul><li>串行无锁化设计，在IO线程内部进行串行操作，避免多线程竞争导致的性能下降。</li><li>通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优</li><li>减少上下文切换，以及状态数据的同步</li></ul></blockquote><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>NIO中的另一大特性——零拷贝，当他需要接收数据的时候，他会在堆内存之外开辟一块内存，数据就直接从IO读到了那块内存中去，在netty里面通过ByteBuf可以直接对这些数据进行直接操作，从而加快了传输速度。</p><p><img src="https://upload-images.jianshu.io/upload_images/1089449-014c9e07d56e4be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/481/format/webp" alt="普通"></p><p><img src="https://upload-images.jianshu.io/upload_images/1089449-50e5aa5eec7e86cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><h2 id="五、Netty学习资料"><a href="#五、Netty学习资料" class="headerlink" title="五、Netty学习资料"></a>五、Netty学习资料</h2><p><a href="https://netty.io/" target="_blank" rel="noopener">Netty官网</a></p><p><a href="https://waylau.gitbooks.io/essential-netty-in-action/content/" target="_blank" rel="noopener">Netty权威指南</a></p><p><a href="https://github.com/netty/netty" target="_blank" rel="noopener">netty-example</a></p><p><a href="http://ifeve.com/tag/netty/" target="_blank" rel="noopener">并发编程网</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信礼品卡踩坑之旅</title>
      <link href="/2019/01/28/%E5%BE%AE%E4%BF%A1%E7%A4%BC%E5%93%81%E5%8D%A1%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85/"/>
      <url>/2019/01/28/%E5%BE%AE%E4%BF%A1%E7%A4%BC%E5%93%81%E5%8D%A1%E8%B8%A9%E5%9D%91%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<p>文中所描述的项目截止于<strong>2018-10</strong>，因此文章内容具有一定<strong>时效性</strong>，请大家注意。本文为博主第一篇博客，不足之处还请各位巨佬们指出:D<br>撰写这篇博客初衷有二：记录自己第一个正式项目的开发历程、为需要<strong>开通微信礼品卡/实现自定义礼品卡小程序</strong>的各位分享一些流程与思路，因此本文总体划为以下部分：</p><blockquote><ul><li>官方礼品卡部署</li><li>自定义小程序实现</li></ul></blockquote><p>项目来自于某公司甲方爸爸的两版需求：第一版为开通官方礼品卡小程序，旗下会员可在其他小程序中利用礼品卡为账户充值，第二版模仿星巴克用星说，开发新的礼品卡小程序。<br>本文面向具有一定经验的微信开发者，微信相关的其他功能（开发者配置、登录、支付等）不再一一赘述。<br>SDK用的是班纳睿大大的<a href="https://github.com/Wechat-Group/WxJava" target="_blank" rel="noopener">WxJava</a>，在此安利一波～</p><a id="more"></a><h1 id="官方礼品卡部署"><a href="#官方礼品卡部署" class="headerlink" title="官方礼品卡部署"></a>官方礼品卡部署</h1><p>先附上官方<del>槽点满满</del>充满诚意的<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=215143440770UT7" target="_blank" rel="noopener">礼品卡文档</a>。<br>这是目前我见过最长（所有内容挤进一篇）、最乱（没有目录，排版不统一，甚至有错别字）的微信文档了。大致讲了以下几点：</p><blockquote><ul><li>小程序演示</li><li>开通条件</li><li>礼品卡CRUD</li><li>货架CRUD</li><li>绑定支付商户</li><li>代码上传</li><li>订单查询</li><li>事件推送</li><li>使用方式</li><li>退款</li><li>发票</li><li>外链跳转</li><li><del>压根不会鸟你的</del>联系我们</li></ul></blockquote><p>WOWEE～看起来啥都给我们api caller准备好了，接下来调就完事了咩～LET’s GO DUDE!</p><h3 id="首先注意"><a href="#首先注意" class="headerlink" title="首先注意"></a>首先注意</h3><p>1、礼品卡亦属于卡券的一个分类，建议先查阅<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=215143440770UT7" target="_blank" rel="noopener">微信卡券文档</a>以便了解相关字段与词汇的含义。<br>2、开通礼品卡的公众号门槛较高，若需开通带储值功能的礼品卡，更是要若干认证与手续，记得提前准备，个人认证的公众号无法申请礼品卡功能。<br>3、创建小程序<strong>不需要写代码</strong>，完全靠接口调用生成。</p><h3 id="接入准备"><a href="#接入准备" class="headerlink" title="接入准备"></a>接入准备</h3><ul><li>公众号-&gt;已认证</li><li>公众号开通-&gt;卡券功能</li><li>公众号开通-&gt;支付功能(微信认证)</li><li>微信公众号-&gt;快速关联小程序(创建小程序账号)</li><li>小程序账号-&gt;绑定 商户号(微信支付)</li></ul><h3 id="礼品卡创建"><a href="#礼品卡创建" class="headerlink" title="礼品卡创建"></a>礼品卡创建</h3><p>json数据，分礼品卡与兑换卡两种，在购买页会有区别。看过卡券文档的朋友们可能会发现，微信没有为卡券做一个完整的分类统计。在这里我可以说，<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1451025283" target="_blank" rel="noopener">会员卡</a>和礼品卡是目前<strong>唯二</strong>可以放入“卡”中的，其余皆为票券，这也为后续的自定义礼品卡实现提供了思路。</p><ul><li>礼品卡的文档中没有对每个字段做详细图解，不过我们可以参照会员卡逐一对照：</li></ul><img src="http://pic.iamhungry.cn/static/images/membercard.png"><h3 id="货架创建"><a href="#货架创建" class="headerlink" title="货架创建"></a>货架创建</h3><p>json数据，货架作为礼品卡的载体，可生成多个，但只能上线其中一个，每行标题对应<code>category_list</code>中的元素，每一小块代表<code>theme_list</code>中的一个元素，将创建完成的礼品卡放入<code>theme_list</code>的<code>item_list</code>字段中，其余字段可自调，创建成功后返回的<code>page_id</code>需要保存，后续会用到。货架包含的字段较多，文档中有详细的解释，这里就不展开了。<br><strong>特别注意：</strong>创建货架的接口每天有调用次数限制，约为<strong>10次/天</strong>，调用前建议校验json格式，检查一遍字段的长度限制。 </p><h3 id="开通支付"><a href="#开通支付" class="headerlink" title="开通支付"></a>开通支付</h3><ol><li>调文档8.1中的接口，带上你公众号的商户号即可，调用成功后访问返回结果中的Url，登录商户平台，产品中心-&gt;微信礼品卡，点击开通。</li><li>8.2接口，带上小程序appid与商户号，成功即开通完成。</li></ol><h3 id="上传生成代码"><a href="#上传生成代码" class="headerlink" title="上传生成代码"></a><del>上传</del>生成代码</h3><p>调用8.3接口，带上对应的<code>appid</code>+<code>page_id</code>，等待片刻后即可在小程序后台看到体验版，扫码进去后看到的约莫是这样子：</p><hr><img src="http://pic.iamhungry.cn/static/images/old_index.jpg?imageView2/2/w/250"><hr><img src="http://pic.iamhungry.cn/static/images/wulian.jpeg"><p>emmm…..<br>基本功能算是都有了，只是这样式…啧啧</p><h3 id="退款问题"><a href="#退款问题" class="headerlink" title="退款问题"></a>退款问题</h3><p> 首先国家法律规定，<strong>必须有退款功能</strong>。所以要做，要是礼品卡过期了、失效了，这也是能退款的，除非你设置了长期有效(不要小看，要相信你的用户是个大牛叉)</p><h3 id="优缺点小结"><a href="#优缺点小结" class="headerlink" title="优缺点小结"></a>优缺点小结</h3><blockquote><ul><li>官方支持，从创建到部署轻松+愉快。可选字段多，扩展业务很方便。有独特的送卡消息，支持扫码消费或者线下核销。</li><li>样式普通，布局简陋，颜值全靠图片衬托。</li></ul></blockquote><h1 id="自定义小程序实现"><a href="#自定义小程序实现" class="headerlink" title="自定义小程序实现"></a>自定义小程序实现</h1><blockquote><p>尽管官方的礼品卡小程序不是很美观，但其他方面还是可以接受的。若要是需求方提到了<strong>星巴克用星说</strong>这玩意并且要给他个差不多样子的，那你就麻烦了。接下来你可能会一阵懵逼，陷入江局——它啥都跟官方的礼品卡小程序一样，但<del>他娘的</del>界面还比你好看，甚至还会有”之前太丑肯定是字段调得不对”的错觉，咱们先看看啥叫别人家的小程序：</p></blockquote><hr><img src="http://pic.iamhungry.cn/static/images/xbk.jpg?imageView2/2/w/250"><hr><img src="http://pic.iamhungry.cn/static/images/xbk_index.jpg?imageView2/2/w/250"><hr><blockquote><ul><li>星巴克用星说是微信团队特别定制的礼品卡小程序，也是自它出现以后，官方才开放了礼品卡的相关文档，可以说是其他礼品卡小程序的始祖。</li></ul></blockquote><p>概括了一下用星说之于其他礼品卡小程序所没有的features：</p><blockquote><ul><li>带阴影的块状元素，看起来更加优雅</li><li>支持gif的轮播图广告</li><li>星巴克风格的icon</li><li>全新的购买界面</li><li>节日期间首页会有活动弹窗</li></ul></blockquote><h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>先放下发麻的头皮，掏出度娘和谷哥捣腾一番后，发觉论坛上也是各种求方案求思路，最有趣的是，还有专门接这类订制礼品卡小程序的公司。<br>其实看到这里我就放心了，既然有人实现了，那它就是可行的，之后我提供的实现方案，不是很优雅，也不够完美，欢迎有做过这类的同好在评论区中分享自己的思路。<br>本节自定义小程序，我们的目标是<strong>模仿星巴克用星说</strong>，有2套思路：</p><blockquote><ul><li>反编译官方小程序获得源码，在其基础上扩展（TODO）</li><li>完全自定义，官方未提供的功能寻求替代方案</li></ul></blockquote><h2 id="反编译实现"><a href="#反编译实现" class="headerlink" title="反编译实现"></a>反编译实现</h2><p>由于工期原因，也考虑到小程序没法过审的风险，没有尝试这一套方案。最近会尝试反编译，看看能否拿到原生礼品卡小程序的源码。（TODO）</p><h2 id="完全自定义实现"><a href="#完全自定义实现" class="headerlink" title="完全自定义实现"></a>完全自定义实现</h2><p>咨询了相关公司（然鹅不肯说=。=），review原生小程序，以及后期的实操经历，我先把这几个无法按原礼品卡小程序实现的点放在这里：</p><blockquote><ul><li>官方礼品卡不能复用(会显示为’已领取’状态但无法领卡)</li><li>不能发礼品卡类型的消息给用户</li><li>无法选择好友或群并返回其信息</li></ul></blockquote><p>特别是接口开放部分，只要是好友链相关，微信都不会给你开放，更不用说选择好友后返回其昵称与头像了，领卡这部分也是一大问题，查阅了JS-SDK和小程序文档，并没有发现可以向用户发送礼品卡信息的方法。所以说，<strong>要百分百模仿用星说是不可能的</strong>。</p><h3 id="Key-Points"><a href="#Key-Points" class="headerlink" title="Key Points"></a>Key Points</h3><p>总的来说，要完成一个像样的实现，以下是关键：</p><blockquote><ul><li>找到一种合适的卡券替代礼品卡</li><li>选择好友的替代方案</li><li>领卡的替代方案</li></ul></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="会员卡代替礼品卡"><a href="#会员卡代替礼品卡" class="headerlink" title="会员卡代替礼品卡"></a>会员卡代替礼品卡</h4><p>在上文中有提到过，礼品卡和会员卡是唯二可以放入”卡”中的卡券。会员卡拥有的字段比礼品卡丰富很多，完全可以替换。在事件推送上，会员卡遵循微信卡券的推送格式，而礼品卡有其独特类型的推送事件，比如超过24小时后未领取退回的事件，这可以做成定时任务代替，问题不大。接口方面，虽然会员卡没有核销接口，但也能用失效接口代替，其余也是应有尽有。<br><strong>特别注意</strong>：用户每次购买应新建一张会员卡，即新的<code>card_id</code>，若发放给用户的卡id相同，当用户选择不同卡面时必会用到更新接口，而更新卡面会影响该id下的所有卡，包括其他用户已领取的会员卡，从而导致所有会员卡卡面都会变化。</p><h4 id="使用分享功能指定发送对象"><a href="#使用分享功能指定发送对象" class="headerlink" title="使用分享功能指定发送对象"></a>使用分享功能指定发送对象</h4><p>分享功能是为数不多用户间发送消息的途径，既然小程序内没法指定发送对象，那我们就直接发送分享消息，虽然不够美观，但也能引导用户点开小程序，这也意味着后续的领卡环节将在小程序里完成。</p><h4 id="小程序内调起领卡"><a href="#小程序内调起领卡" class="headerlink" title="小程序内调起领卡"></a>小程序内调起领卡</h4><p>在小程序内做一个领取页，后台先准备好待领取卡的<code>JsApiTicket</code>，前段调用小程序的<a href="https://developers.weixin.qq.com/miniprogram/dev/api/wx.addCard.html" target="_blank" rel="noopener">发卡接口</a>调起官方领卡页面，放入卡包后跳转至领取成功的页面。整个环节最突兀的是官方领卡显示为会员卡且无法更改，这是做的不好的地方。</p><h3 id="成品展示"><a href="#成品展示" class="headerlink" title="成品展示"></a>成品展示</h3><img src="http://pic.iamhungry.cn/static/images/new_index.jpg?imageView2/2/w/250"><hr><img src="http://pic.iamhungry.cn/static/images/singlecargo.jpg?imageView2/2/w/250"><ul><li>按需求做了单品购买</li></ul><hr><img src="http://pic.iamhungry.cn/static/images/send_to.jpg?imageView2/2/w/250"><ul><li>增加抢红包模式</li></ul><hr><img src="http://pic.iamhungry.cn/static/images/myCard.jpg?imageView2/2/w/250"><hr><img src="http://pic.iamhungry.cn/static/images/getCard.jpg?imageView2/2/w/250"><hr><img src="http://pic.iamhungry.cn/static/images/getCardPage.jpg?imageView2/2/w/250"><hr><blockquote><p>关于样式方面，可以参考liaoruochen的<a href="https://github.com/liaoruochen/Starbucks" target="_blank" rel="noopener">Starbucks</a>，做的很全面，很漂亮。</p></blockquote><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>感谢和我共事的小老弟们，在样式上花了很多功夫，也在这个项目上付出了很多时间，感谢你们。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://github.com/liaoruochen/Starbucks" target="_blank" rel="noopener">[简书] 微信礼品卡</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>404</title>
      <link href="//404.html"/>
      <url>//404.html</url>
      
        <content type="html"><![CDATA[<style type="text/css">    .article-header {        padding: 0;        padding-top: 26px;        border-left: none;        text-align: center;    }    .article-header:hover {        border-left: none;    }    .article-title {        font-size: 2.1em;    }    strong a {        color: #747474;    }    .article-meta {        display: none;    }    .share {        display: none;    }    .ds-meta {        display: none;    }    .player {        margin-left: -10px;    }    .sign {        text-align: right;        font-style: italic;    }      #page-visit {        display: none;    }    .center {        text-align: center;        height: 2.5em;        font-weight: bold;    }    .article-entry hr {        margin: 0;    }    .pic {        text-align: center;        margin: 0;    }    .pic br {          display: none;      }    #container .article-info-post.article-info {      display: none;      }    #container .article .article-title {    padding: 0;    }</style>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
